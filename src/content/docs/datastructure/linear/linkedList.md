---
title: ' 連結リスト (LinkedList)'
description: '連結リスト (LinkedList)の定義、特徴、時間計算量、長所と短所について。'
---

1.0 連結リストの基本概念

1.1. データ構造の選択は、プログラム全体のパフォーマンスとスケーラビリティを左右する極めて重要な設計判断です。その中でも連結リストは、その単純さとは裏腹に、データ要素の挿入や削除が頻繁に発生する動的なシナリオにおいて、配列などの静的なデータ構造を凌駕する効率性を発揮します。この資料では、連結リストがなぜコンピュータサイエンスの基本でありながら、今日でも多くのシステムで活用され続ける強力なツールであるのか、その構造、利点、そして戦略的な活用法を深く掘り下げていきます。

1.2. 連結リストの定義 連結リスト（Linked List）とは、ノード（Node） と呼ばれる要素を用いてデータを格納する線形データ構造です。各ノードが次のノードへの参照（ポインタ）を持つことで、物理的なメモリ上では非連続であっても、論理的に連続したデータの繋がりを形成します。

連結リストを構成する核となる要素は以下の通りです。

* ノード (Node): データ（値）を保持する「データ部」と、リスト内の次のノードを指し示す「ポインタ（参照）部」から構成される基本単位です。
* ポインタ (Pointer / Reference): あるノードから次のノードへのリンクを確立する役割を担います。このポインタによってノード同士が鎖のように連結され、リスト全体が形成されます。
* ヘッド (Head): リストの開始点となる最初のノードを指すポインタです。リスト全体にアクセスするためのエントリーポイントとなります。
* Null: リストの終端を示す特別なポインタの値です。最後のノードのポインタ部がNullを指すことで、リストの終わりを示します。

1.3. 配列との比較分析 連結リストと配列は、どちらも線形データ構造ですが、その内部構造とメモリ管理の方法には根本的な違いがあります。この違いを理解することは、適切なデータ構造を選択する上で不可欠です。

特徴	連結リスト	配列
データ構造	非連続的 (Non-contiguous)	連続的 (Contiguous)
メモリ割り当て	個々の要素に都度割り当て	配列全体に一括で割り当て
挿入/削除	効率的	非効率的
アクセス方法	シーケンシャルアクセス	ランダムアクセス

1.4. 上記の比較から明らかなように、連結リストは特に、データコレクションのサイズが予測不可能であったり、実行中に要素の挿入や削除が頻繁に行われたりするシナリオでその真価を発揮します。配列が要素の移動にコストを要するのに対し、連結リストはいくつかのポインタを再接続するだけで済むため、非常に効率的です。次のセクションでは、この基本概念を基に、連結リストの具体的な種類とその構造について詳しく見ていきます。

2.0 連結リストの主な種類と構造

2.1. 一口に「連結リスト」と言っても、すべての構造が同じわけではありません。ノードの連結方法、つまりポインタの持ち方によって構造が異なり、その違いが特定のタスクにおける効率や機能性を大きく左右します。このセクションでは、最も基本的で広く利用されている「単方向連結リスト」と「双方向連結リスト」の構造と特徴を分析します。

2.2. 単方向連結リスト (Singly Linked List) 単方向連結リストは、最もシンプルな形式の連結リストです。各ノードは「データ」と「次のノードへのポインタ（next）」の2つの部分で構成されています。この構造により、各ノードは自分の次にどのノードが来るかしか知りません。その結果、リストの走査（Traversal）は常にヘッドから終端に向かう一方向へのみ可能という運用的特徴を持ちます。リストの終端に到達すると、nextポインタはNullを指します。

2.3. 双方向連結リスト (Doubly Linked List) 双方向連結リストは、単方向リストの機能性を拡張したものです。各ノードは「データ」、「次のノードへのポインタ（next）」、そして「前のノードへのポインタ（prev）」の3つのフィールドで構成されます。この追加されたprevポインタが、双方向連結リストの最大の利点をもたらします。それは、リストを前方（ヘッドから終端へ）だけでなく、後方（終端からヘッドへ）にも双方向に走査できるという点です。この柔軟性により、特定のノードからの要素の削除や、Webブラウザの「戻る/進む」機能のような実装が非常に効率的になります。

2.4. 単方向リストと双方向リストの選択は、メモリ消費量と機能性のトレードオフを考慮する必要があります。双方向リストはprevポインタを保持するためにノードごとに追加のメモリを必要としますが、その代わりに双方向の走査と、特定のノードを基準とした効率的な削除操作という強力な機能を提供します。これらの構造の違いが、実際のデータ操作にどのような影響を与えるのかを次のセクションで詳しく掘り下げていきましょう。

3.0 連結リストの利点と戦略的活用

3.1. 連結リストの理論的な構造を理解するだけでは不十分です。その利点がどのような実用的な問題解決につながるかを評価し、戦略的に活用することがエンジニアには求められます。このセクションでは、連結リストが提供する主要な強みを分析し、それがなぜ特定のアプリケーションにおいて最適な選択肢となるのかを解説します。

3.2. 連結リストの主要な利点

* 効率的な挿入と削除 連結リストの最大の利点は、要素の挿入と削除がO(1)の計算量で完了することです。これは、操作対象のノードの前後のポインタを再接続するだけで処理が完了し、配列のように後続の要素をすべてシフトする必要がないためです。例えば、配列で百万件のデータの中間に要素を一つ挿入するには、後続の要素すべてをメモリ上でシフトさせるという膨大なコストが発生しますが、連結リストではポインタを数本つなぎ替えるだけで瞬時に完了します。この特性は、リアルタイムでデータが頻繁に追加・削除されるようなアプリケーションにおいて絶大な価値を持ちます。
* 動的なサイズ 配列は宣言時にサイズを固定するか、動的配列であっても容量を超えると高コストな再割り当てが発生します。一方、連結リストは事前にサイズを決定する必要がなく、実行時に必要な数だけノードを追加・削除できます。データ量が予測できない場合や、メモリを無駄なく使用したい場合に非常に有効な選択肢となります。
* データ構造の実装基盤 連結リストは、それ自体が強力なデータ構造であると同時に、スタックやキュー、グラフ（隣接リスト表現）といった、より高度な抽象データ構造を実装するための優れた基盤となります。特にキューにおいて、先頭からの要素の削除（デキュー）がO(1)で実行できるため、配列を用いた実装よりも遥かに効率的です。ほとんどのプログラミング言語の標準ライブラリが、内部的にキューを連結リストで実装しているのはこのためです。

3.3. 連結リストが持つこれらの強力な利点を踏まえると、どのようなアプリケーションでその強みが活かされているかが自ずと見えてきます。次のセクションでは、これらの利点が具体的なソフトウェアやシステムでどのように活用されているかを見ていきましょう。

4.0 連結リストの欠点と考慮事項

4.1. いかなるデータ構造も万能ではなく、特定のシナリオで強みを発揮する一方で、他のシナリオでは弱点を露呈します。連結リストの限界とトレードオフを正確に理解することは、プロジェクトの要件に対して最適な技術選定を行うために不可欠です。このセクションでは、連結リストを採用する際に考慮すべき主要な欠点を分析します。

4.2. 連結リストの主要な欠点

* 低速なアクセス時間 連結リストの要素にアクセスするには、必ずリストの先頭（ヘッド）からポインタを順にたどる必要があります。そのため、特定のn番目の要素にアクセスするための計算量はO(n)となり、要素数が多くなるほど時間がかかります。インデックスを用いてO(1)で要素にアクセスできる配列とは対照的であり、インデックスベースの高速なランダムアクセスが求められる場面には不向きです。
* 追加のメモリオーバーヘッド 各ノードは、格納するデータ本体に加えて、次のノード（双方向リストの場合は前のノードも）を指すためのポインタを保持する必要があります。このポインタが追加のメモリオーバーヘッドとなり、特に大量の小さな要素（例えば、文字や整数など）を格納する場合、データそのものよりもポインタが占めるメモリ量の割合が大きくなり、非効率になる可能性があります。
* キャッシュ非効率性 現代のCPUは、メモリからデータを高速に読み出すためにキャッシュメモリを利用します。配列のようにデータがメモリ上で連続して配置されている場合、CPUは一度に複数の要素をキャッシュに読み込むことができ（空間的局所性）、これが走査パフォーマンスを向上させます。しかし、連結リストのノードはメモリ上に非連続的に配置される傾向があるため、キャッシュの局所性を活かせず、結果として配列に比べて走査性能が低下する可能性があります。このキャッシュ効率の低さは、連結リストが持つ「動的なサイズ」と「柔軟なメモリ割り当て」という利点の裏返しと言えます。メモリのどこにでもノードを配置できる自由度が、CPUの予測可能性を犠牲にしているのです。

4.3. 連結リストの長所（効率的な挿入/削除）と短所（低速なアクセス）を比較検討した上で、アプリケーションの要件にどちらがより重要かを判断する必要があります。理論的な特性を理解したところで、次は連結リストが実際にどのような場面で輝くのか、具体的なユースケースを見ていきましょう。

5.0 連結リストの実用的な応用例

5.1. データ構造の理論的な知識を、現実世界のソフトウェア開発に結びつけることは、ジュニア開発者がシニアへと成長する上で重要なステップです。このセクションでは、これまで学んだ連結リストの特性が、オペレーティングシステムから日常的に使うアプリケーションまで、どのように現実世界の問題解決に活用されているか、具体的な応用例を紹介します。

5.2. システムレベルでの応用 オペレーティングシステムやコンパイラといった、コンピュータの根幹を支えるソフトウェアでは、連結リストの動的な性質が不可欠です。

* 動的メモリ割り当て: OSは、利用可能なメモリブロック（空きブロック）を連結リストで管理しています。プロセスがメモリを要求すると、このリストから適切なサイズのブロックを切り出して割り当て、不要になればリストに戻します。
* プロセススケジューリング: ラウンドロビンスケジューリングのようなアルゴリズムでは、実行待ちのプロセスキューをサーキュラーリンクリスト（循環連結リスト）で実装し、プロセスを公平に切り替えながら実行します。
* グラフの隣接リスト表現: グラフ構造を表現する際、各頂点に接続されている他の頂点のリストを連結リストで保持する方法は、メモリ効率が良く、頂点の追加・削除も容易です。

5.3. アプリケーションレベルでの応用 私たちは、日常的に連結リストの恩恵を受けているソフトウェアを使用しています。

* Webブラウザの「戻る/進む」機能: 閲覧したページの履歴は、双方向連結リストで管理されています。「戻る」ボタンはprevポインタを、「進む」ボタンはnextポインタをたどることで実現されており、まさに双方向リストの典型的な応用例です。
* 音楽プレイヤーのプレイリスト: プレイリスト内の曲は双方向連結リストで構成されており、「次の曲へ」「前の曲へ」といった操作を効率的に行えます。
* 画像ビューアの「次へ/前へ」機能: 画像ビューアで前後の画像に移動する機能も、双方向連結リストによって実現されています。
* LRUキャッシュの実装: Least Recently Used (LRU) キャッシュアルゴリズムでは、双方向連結リストを用いてデータのアクセス順序を管理します。最も最近使われたアイテムをリストの先頭に移動し、キャッシュが溢れた際はリストの末尾（最も使われていないアイテム）を削除することで、効率的なキャッシュ管理を実現します。

5.4. これらの例が示すように、連結リストは決して机上の理論ではありません。これらの実用例を理解することで、連結リストの知識をより深く定着させ、最後の要点整理へと進みましょう。

6.0 結論：キーポイントのまとめ

6.1. このトレーニング資料を通じて、連結リストの基本的な概念から応用例までを解説しました。ジュニア開発者として、以下の重要なポイントを確実に押さえておきましょう。これらは、将来あなたがデータ構造を選択する際の、思考の基盤となるはずです。

1. 挿入/削除の効率性 vs. アクセスの非効率性 連結リストの最大の強みは、O(1)での高速な要素の挿入・削除です。データ量が予測できず、頻繁に変更が発生するシナリオでは、配列に対する明確な優位性を持ちます。しかし、特定の要素へのアクセスはO(n)であり、ランダムアクセスが頻繁に必要な場合は配列を選択すべきです。
2. 動的なメモリ管理 実行時にサイズを柔軟に変更できるため、事前にデータ量を確保する必要がありません。これにより、メモリを効率的に使用することが可能になります。この特性は、メモリが限られている環境や、データ量が大きく変動するアプリケーションで特に重要です。
3. 構造のトレードオフ（単方向 vs. 双方向） 単方向リストはシンプルでメモリ消費が少ない一方、走査は一方向に限定されます。双方向リストは追加のメモリ（prevポインタ）を必要としますが、双方向の走査と柔軟な操作性を提供します。Webブラウザの履歴機能のように、前方と後方の両方への移動が必要な場合は双方向リストが最適です。
4. 他のデータ構造の基盤 連結リストは、スタック、キュー、グラフといった、より複雑なデータ構造を効率的に実装するための foundational なツールです。特にキューの実装において、先頭からの削除が高速である点は大きな利点となります。

6.2. 最終的に、データ構造の選択は常にアクセスパターンと変更頻度のトレードオフを分析することから始まります。この原則を念頭に置くことで、あなたはより堅牢でスケーラブルなシステムを設計できるエンジニアへと成長するでしょう。


https://www.geeksforgeeks.org/dsa/linked-list-data-structure/

https://www.geeksforgeeks.org/dsa/singly-linked-list-tutorial/

https://www.geeksforgeeks.org/dsa/doubly-linked-list/

https://www.geeksforgeeks.org/dsa/applications-advantages-and-disadvantages-of-linked-list/