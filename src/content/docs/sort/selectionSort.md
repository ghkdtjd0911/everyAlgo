---
title: '選択ソート(Selection Sort)'
description: 'TODO'
sidebar:
  order: 3
---
選択ソートアルゴリズム：基本概念と実践的分析

1. 選択ソートの基本概念

選択ソートは、比較ベースの基本的なソートアルゴリズムの一つです。データ構造とアルゴリズムの強固な基礎を築く上で、その中心的なメカニズムを理解することは戦略的に重要です。このアルゴリズムのループ構造とインプレース操作を理解することは、挿入ソートや、より複雑なヒープソートといったアルゴリズムを解析するための基礎となります。

選択ソートは、比較ベースのソートアルゴリズムとして定義されます。その主な動作原理は、配列の未ソート部分から**最小（または最大）**の要素を繰り返し見つけ出し、その未ソート部分の先頭要素と交換することです。このプロセスを配列全体がソートされるまで続けます。この単純な原理が、明確で段階的なプロセスへとつながっていきます。

2. アルゴリズムの動作プロセス

選択ソートのステップバイステップのロジックを習得することは、アルゴリズムを正しく実装し、配列がどのように段階的にソートされていくかを視覚化するために不可欠です。以下に、その具体的なプロセスを詳述します。

1. 配列全体から最小の要素を見つけ出し、最初の要素と交換します。これにより、最小の要素が正しい位置に配置されます。
2. 残りの未ソート部分から最小の要素（つまり、2番目に小さい要素）を見つけ出し、2番目の要素と交換します。
3. このプロセスを、配列全体がソートされるまで繰り返します。

このプロセスを、具体的な例を使って見ていきましょう。初期配列を { 64, 25, 12, 22, 11 } とします。

* 最初のパス (Pass 1):
  * 初期配列: { 64, 25, 12, 22, 11 }
  * 配列全体から最小値である 11 を見つけます。
  * 11 を先頭の 64 と交換します。
  * パス1完了後の配列: **{ 11,** 25, 12, 22, 64 }
* 2番目のパス (Pass 2):
  * インデックス1以降の未ソート部分 { 25, 12, 22, 64 } から最小値である 12 を見つけます。
  * 12 を未ソート部分の先頭である 25 と交換します。
  * パス2完了後の配列: **{ 11, 12,** 25, 22, 64 }

この機械的なプロセスは、アルゴリズムのパフォーマンスに直接的な影響を与えます。

3. パフォーマンス分析

パフォーマンス分析は、開発者にとって極めて重要なスキルです。時間計算量と空間計算量を理解することは、特定のタスクに対してアルゴリズムの適合性を評価する鍵となります。

3.1. 時間計算量

選択ソートの時間計算量は O(n²) です。

この計算量になる理由は、アルゴリズムが2つのネストされたループで構成されているためです。外側のループが配列の要素を一つずつ選択するために実行され（O(n)）、内側のループが残りの配列から最小要素を見つけるために実行されます（O(n)）。その結果、全体の計算量は O(n) * O(n) = O(n²) となります。

重要な点として、この O(n²) の計算量は最良、平均、最悪のすべてのケースに適用されます。なぜなら、データがすでにソートされている場合でも、アルゴリズムは常に配列全体を走査する必要があるからです。

3.2. 空間計算量

補助的な空間計算量は O(1) です。

これは、選択ソートがインプレース（in-place）ソートアルゴリズムであることを意味します。ソート処理に追加で必要となるメモリは、要素を交換する際に使用する一時的な変数のための定数領域のみです。

これらのパフォーマンス特性は、次に示すような明確な長所と短所につながります。

4. 選択ソートの評価：長所と短所

あらゆる状況で完璧なアルゴリズムというものは存在しません。選択ソートの価値は、その特定のトレードオフを理解し、どのような場面で適切な選択肢となるかを見極めることにあります。

4.1. 主な長所

* 実装の容易さ (Ease of Implementation): ロジックが非常に単純明快であるため、ソートの基本概念を学ぶための理想的なアルゴリズムです。
* メモリ効率 (Memory Efficiency): O(1)の追加メモリ空間しか必要としないインプレース性のため、メモリ使用量が制約される環境で有利です。
* スワップ回数の少なさ (Minimal Swaps): 他の多くのソートアルゴリズムと比較して、メモリへの書き込み（スワップ）回数が少なくなります。これは、メモリ書き込みが高コストな処理となるシナリオにおいて、大きな利点となります。

4.2. 主な短所

* 非効率な時間計算量 (Inefficient Time Complexity): O(n²) という時間計算量は、マージソートやクイックソートのようなより高速なアルゴリズムと比較して著しく遅く、大規模なデータセットには不向きです。
* 不安定ソート (Unstable Sort): 安定ソートとは、値が等しい要素の相対的な順序を維持するソートアルゴリズムを指します。選択ソートは安定ソートではありません。その理由は、最小値を見つけて先頭要素と交換する際に、要素が長距離を移動する可能性があるためです。例えば、{ 5a, 8, 5b, 2 } のように、値は同じでも区別可能な要素を持つ配列を考えます（5aと5bは値が同じ）。最初のパスで最小値 2 が見つかり、先頭の 5a と交換されます。その結果、配列は { 2, 8, 5b, 5a } となり、5a と 5b の元の順序が逆転してしまいました。このように、スワップ操作が等しい値を持つ要素の相対順序を破壊してしまうため、不安定とされます。

これらの特性は、選択ソートが最も有用となる特定のシナリオを定義します。

5. 実用的な適用シナリオ

理論的な知識から実践的な応用へと移行することは重要です。このセクションでは、選択ソートがその限界にもかかわらず、実行可能で論理的な選択肢となる特定の状況を特定します。

* 教育目的 (Educational Purposes): そのシンプルさから、ソートアルゴリズムやアルゴリズム的思考の基礎を教えるための完璧なツールとなります。
* 小規模なデータセット (Small Datasets): リストが小さい場合、O(n²) のパフォーマンスは許容範囲内であり、より複雑なアルゴリズムに伴うオーバーヘッドは正当化されません。
* メモリ書き込みコストが高い場合 (When Memory Writes are Costly): スワップ回数が最小限であるため、メモリへの書き込みが高価な特定の環境において実用的な選択肢となります。例えば、書き込み回数に上限があるフラッシュメモリ（SSDなど）を使用した組込みシステムでは、書き込み処理を最小限に抑えることがハードウェアの寿命を延ばす上で重要になります。これは一般的なアプリケーション開発では稀ですが、特定のエンジニアリング分野では決定的な利点となり得ます。

また、より高度なアルゴリズムであるヒープソートは、選択ソートの概念に基づいています。

これらの点を踏まえ、最後に選択ソートの重要なポイントをまとめます。

6. 要点整理

選択ソートに関する最も重要な情報を、ジュニア開発者が迅速に参照できるよう、簡潔な箇条書きにまとめます。

* 中心的なメカニズム: 未ソート部分から最小要素を見つけ出し、正しい位置に交換する。
* 時間計算量: すべてのケース（最良、平均、最悪）で O(n²) であり、大規模なデータセットには非効率。
* 空間計算量: O(1) の補助領域しか必要としないインプレースアルゴリズム。
* 主な強み: スワップ（メモリ書き込み）回数を最小限に抑えるため、書き込みコストが高い場合に有益。
* 主な弱み: 不安定なソートアルゴリズムであり、等しい値を持つ要素の元の順序が保証されない。
* 主な用途: 小規模なデータセットや教育目的での利用に最適。

```
// Java program for implementation of Selection Sort
import java.util.Arrays;

class GfG {

    static void selectionSort(int[] arr){
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
          
            // Assume the current position holds
            // the minimum element
            int min_idx = i;

            // Iterate through the unsorted portion
            // to find the actual minimum
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[min_idx]) {
                  
                    // Update min_idx if a smaller element
                    // is found
                    min_idx = j;
                }
            }

            // Move minimum element to its
            // correct position
            int temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;           
        }
    }

    static void printArray(int[] arr){
        for (int val : arr) {
            System.out.print(val + " ");
        }
        System.out.println();
    }
  
    public static void main(String[] args){
        int[] arr = { 64, 25, 12, 22, 11 };

        System.out.print("Original array: ");
        printArray(arr);

        selectionSort(arr);

        System.out.print("Sorted array: ");
        printArray(arr);
    }
}

```


https://www.geeksforgeeks.org/dsa/selection-sort-algorithm-2/