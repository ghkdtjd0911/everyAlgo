---
title: 'バブルソート(Bubble Sort)'
description: 'TODO'
sidebar:
  order: 2
---

バブルソートアルゴリズム：基礎概念と実践的分析

1. バブルソートの基本原則

ソフトウェア開発者としてのキャリアの初期段階では、バブルソートのような基本的なソートアルゴリズムを理解することが極めて重要です。これらのアルゴリズムは、より複雑な問題解決能力を構築するための基礎となる概念だからです。単純でありながら、アルゴリズムの動作原理、パフォーマンス評価、最適化といった核心的なテーマを学ぶための優れた出発点となります。

バブルソートは、「隣接する要素が正しい順序でない場合に、それらを繰り返し交換する」ことによって機能する最もシンプルなソートアルゴリズムです。その名前は、配列内の最も大きい要素が、まるで泡（バブル）が水面に浮かび上がるように、一度のパスを経て配列の最後に移動する様子に由来します。

このアルゴリズムの中核的なメカニズムは、以下のステップに分解できます。

1. 隣接要素の比較と交換 (Comparison and Swapping of Adjacent Elements) アルゴリズムの基本操作は、配列内の隣接する2つの要素を比較することです。もし最初の要素が2番目の要素よりも大きい場合、つまり順序が間違っている場合は、2つの要素を交換（スワップ）します。この操作を配列の先頭から末尾に向かって繰り返します。
2. パス単位の処理 (Processing in Passes) バブルソートは、配列全体を複数回スキャンする「パス」という単位で処理を進めます。1回のパスでは、未整列部分の先頭から末尾まで隣接要素の比較と交換を繰り返します。
3. 最大要素の確定 (Fixing the Maximum Element) 最初のパスが完了すると、配列内で最も大きい要素が正しい最終位置（配列の末尾）に配置されます。同様に、2回目のパスが完了すると、2番目に大きい要素がその最終位置（末尾から2番目）に配置されます。このように、k回のパスが完了すると、k個の最も大きい要素が配列の末尾k個の位置に正しく配置されることが保証されます。

この基本原則を理解した上で、次にアルゴリズムが具体的にどのように動作するのかを、ステップバイステップで詳しく見ていきましょう。

2. 動作プロセスと最適化

アルゴリズムの動作をステップごとに視覚化し、その最適化手法を理解することは、デバッグやパフォーマンスチューニングを行う上で不可欠なスキルです。特にバブルソートのようなシンプルなアルゴリズムは、これらの概念を具体的に学ぶための絶好の機会を提供してくれます。

例として、配列 { 64, 34, 25, 12, 22, 11, 90 } をソートするプロセスを見てみましょう。ここでは、最初のパスで要素がどのように「浮かび上がって」いくかに注目します。

最初のパスの実行例: (配列: { 64, 34, 25, 12, 22, 11, 90 })

比較対象	比較結果	アクション	配列の状態
{ **64, 34** }	64 > 34	交換	{ 34, **64**, 25, 12, 22, 11, 90 }
{ **64, 25** }	64 > 25	交換	{ 34, 25, **64**, 12, 22, 11, 90 }
{ **64, 12** }	64 > 12	交換	{ 34, 25, 12, **64**, 22, 11, 90 }
{ **64, 22** }	64 > 22	交換	{ 34, 25, 12, 22, **64**, 11, 90 }
{ **64, 11** }	64 > 11	交換	{ 34, 25, 12, 22, 11, **64**, 90 }
{ **64, 90** }	64 < 90	交換なし	{ 34, 25, 12, 22, 11, 64, **90** }

パス完了後、最大値 90 が末尾に確定。

最適化手法

バブルソートは、swapped というブール型のフラグを導入することで最適化できます。このフラグの役割は、あるパスの内部ループで一度も要素の交換が発生しなかった場合を検知することです。交換が一度もなかったということは、その時点で配列がすでに完全にソートされていることを意味します。この最適化により、アルゴリズムは不要なパスを省略し、すべてのパスを完了する前に早期に終了できます。これは、すでにソート済み、あるいはほぼソート済みのデータに対して特に効果的です。

最適化されたバブルソートのコアロジックは、以下の擬似コードで表現できます。

procedure bubbleSort(array)
  n = length of array
  for i from 0 to n-2
    swapped = false
    // 内側ループの境界が狭まるのは、各パスの後、
    // 最大要素がすでに最終位置に配置されているため。
    for j from 0 to n-i-2
      if array[j] > array[j+1]
        swap(array[j], array[j+1])
        swapped = true
      end if
    end for
    // 最適化：内側ループで交換が一度も発生しなければ、
    // 配列はソート済みなので早期に終了できる。
    if not swapped
      break
    end if
  end for
end procedure


アルゴリズムがどのように機能するかを理解したところで、次はそのパフォーマンスを形式的に測定する方法について見ていきましょう。

3. パフォーマンス分析：計算量

アルゴリズムの性能を評価するためには、計算量（Complexity Analysis）の概念を理解することが不可欠です。時間計算量と空間計算量は、アルゴリズムが特定のタスクやデータ規模に対してどれだけ効率的かを判断するための指標であり、この分析はプロのソフトウェア開発における中核的な能力の一つです。

バブルソートの計算量は以下の通りです。

種類 (Type)	計算量 (Complexity)	分析 (Analysis)
時間計算量 (Time Complexity)	O(n²)	この計算量は、ネストされた2つのループに起因します。データセットが大きくなるにつれて実行時間が二次関数的に増加するため、大規模データには非効率です。
空間計算量 (Auxiliary Space)	O(1)	このアルゴリズムは、ソート対象の配列以外に追加のメモリを必要としない「インプレース」な操作です。これはメモリ効率の観点から大きな利点となります。

O(n²)という時間計算量の現実的な意味を考えることが重要です。これは、要素数 n が2倍になると、実行時間が約4倍になることを示します。例えば、1万個の要素をソートするのに1秒かかるとすれば、2万個の要素では4秒、10万個の要素では100秒（約1分40秒）かかる計算になります。この急激な増加により、バブルソートは大規模なアプリケーションでの利用には実用的ではありません。

パフォーマンスの定量的分析を踏まえ、次にこのアルゴリズムの長所と短所を定性的に評価してみましょう。

4. バブルソートの評価：長所と短所

ソフトウェアエンジニアリングの世界では、あらゆるアルゴリズムがトレードオフの集合体です。特定の状況で優れているアルゴリズムも、別の状況では不適切かもしれません。バブルソートの具体的な長所と短所を理解することで、開発者はいつこのアルゴリズムを検討すべきか（そして、いつ避けるべきか）を的確に判断できるようになります。

長所 (Advantages)

* 実装の容易さ (Ease of Implementation) バブルソートのロジックは非常に直感的で単純なため、実装が容易です。このシンプルさは、ソートアルゴリズムの基本を学ぶための教育的なツールとして非常に優れています。
* 追加メモリ不要 (No Additional Memory Required) O(1)の補助空間計算量が示す通り、バブルソートは追加のメモリをほとんど消費しません。この特性は、メモリリソースが極端に制限された環境で作業する場合に利点となります。
* 安定ソート (Stable Sort) バブルソートは「安定なソートアルゴリズム」です。これは、同じ値を持つ要素がソート後も元の相対的な順序を維持することを意味します。この性質は、複数のキーでデータをソートするような特定のデータ処理シナリオにおいて価値があります。

短所 (Disadvantages)

* 非効率な時間計算量 (Inefficient Time Complexity) O(n²)という時間計算量は、バブルソートの最大の弱点です。データセットのサイズが大きくなるにつれてパフォーマンスが著しく低下するため、パフォーマンスが重視されるアプリケーションには全く適していません。
* 限定的な実用性 (Limited Real-World Application) 上記の非効率性から、バブルソートが実際の製品やシステムで使われることはほとんどありません。その主な用途は、ソートの概念を教えるための学術的な場面に限定されます。

これらの評価を通じて、バブルソートの特性が明らかになりました。最後に、本ドキュメントの要点をまとめます。

5. まとめ：主要なポイント

ジュニア開発者としてバブルソートから学ぶべき最も重要なポイントは、アルゴリズムの基本的な考え方とその評価方法です。以下に主要なポイントをまとめます。

1. 中核的なメカニズム 「隣接要素の比較と交換」という単純な操作が、いかにして全体のソートを実現するのかを完全に理解してください。
2. パフォーマンスの特性 O(n²)の時間計算量とO(1)の空間計算量というトレードオフは、アルゴリズム選定における最も基本的な思考訓練です。
3. 主なユースケース バブルソートを学ぶ目的は、本番コードで「使う」ためではなく、アルゴリズムの基礎と性能評価を「学ぶ」ためです。


``` 
// Optimized java implementation of Bubble sort
import java.io.*;

class GFG {
    
    // An optimized version of Bubble Sort
    static void bubbleSort(int arr[], int n){
        int i, j, temp;
        boolean swapped;
        for (i = 0; i < n - 1; i++) {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    
                    // Swap arr[j] and arr[j+1]
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            // If no two elements were
            // swapped by inner loop, then break
            if (swapped == false)
                break;
        }
    }

    // Function to print an array
    static void printArray(int arr[], int size){
        int i;
        for (i = 0; i < size; i++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    // Driver program
    public static void main(String args[]){
        int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
        int n = arr.length;
        bubbleSort(arr, n);
        System.out.println("Sorted array: ");
        printArray(arr, n);
    }
}

```



https://www.geeksforgeeks.org/dsa/bubble-sort-algorithm/

